import fitz  # PyMuPDF
import os
import cv2 # OpenCV for image processing
import numpy as np # For numerical operations
# --- Perspective Rectification Helper Functions ---
def order_points(pts):
    """
    Order points in the sequence: top-left, top-right, bottom-right, bottom-left.
    """
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def rectify_page_color(img_color: np.ndarray, debug_prefix: str) -> np.ndarray:
    """
    Detect the page boundary and apply a perspective transform
    to rectify skew and perspective distortion.
    """
    print(f"  - Detecting page boundary for perspective rectify (prefix: {debug_prefix})")
    gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    # Close gaps in edges
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
    closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
    contours, _ = cv2.findContours(closed, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        print("  - Warning: No contours found for page rectification. Skipping rectification.")
        return img_color
    # Find the largest 4-point contour
    contours = sorted(contours, key=cv2.contourArea, reverse=True)
    page_cnt = None
    for cnt in contours:
        peri = cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
        if len(approx) == 4:
            page_cnt = approx.reshape(4, 2)
            break
    if page_cnt is None:
        print("  - Warning: No 4-point contour found. Skipping rectification.")
        return img_color
    rect = order_points(page_cnt)
    (tl, tr, br, bl) = rect
    # Compute dimensions of new image
    widthA = np.linalg.norm(br - bl)
    widthB = np.linalg.norm(tr - tl)
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.linalg.norm(tr - br)
    heightB = np.linalg.norm(tl - bl)
    maxHeight = max(int(heightA), int(heightB))
    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]
    ], dtype="float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(img_color, M, (maxWidth, maxHeight),
                                 flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)
    if SAVE_DEBUG_IMAGES:
        cv2.imwrite(os.path.join(DEBUG_DIR, f"{debug_prefix}_rectified.png"), warped)
    print("  - Page rectification complete")
    return warped

# skimage.transform.rotate often provides better interpolation for deskewing
try:
    from skimage.transform import rotate
    from skimage import img_as_ubyte # To convert rotated float image back to uint8
    USE_SKIMAGE_ROTATE = True
except ImportError:
    print("Warning: scikit-image not found. Falling back to OpenCV rotate.")
    print("         For potentially better rotation quality, install it: pip install scikit-image")
    USE_SKIMAGE_ROTATE = False
# Dedicated deskew library
try:
    from deskew import determine_skew
    USE_DESKEW_LIB = True
except ImportError:
     print("Warning: deskew library not found. Skew correction will be skipped.")
     print("         Install it for skew correction: pip install deskew")
     USE_DESKEW_LIB = False

from werkzeug.utils import secure_filename
import time # For unique debug filenames

# --- Configuration ---
PROCESSED_DIR = "processed"
PDF_DPI = 300
# --- Skew/Crop Parameters (Tune these as needed) ---
MAX_SKEW_ANGLE = 15        # Max angle (degrees) considered valid skew (deskew lib often less sensitive)
# MIN_SKEW_THRESHOLD = 0.05  # deskew library often filters internally, threshold might not be needed here
CROP_PADDING = 15          # Pixels padding around detected content for crop_to_content
# --- Debugging ---
SAVE_DEBUG_IMAGES = True   # Set to False in production to save disk space/time
DEBUG_DIR = "debug_images" # Folder to save intermediate images

# --- Helper Functions ---

def ensure_dir(directory):
    """Creates a directory if it doesn't exist."""
    if not os.path.exists(directory):
        try:
            os.makedirs(directory)
            print(f"Created directory: {directory}")
        except OSError as e:
            print(f"Error creating directory {directory}: {e}")
            # Depending on severity, you might want to raise the exception

# Create debug directory if saving is enabled
if SAVE_DEBUG_IMAGES:
    ensure_dir(DEBUG_DIR)

def crop_to_content(gray_image: np.ndarray, padding=10, debug_prefix="crop") -> np.ndarray:
    """
    Crops a grayscale image to the bounding box of its content using contours.

    Args:
        gray_image: The input grayscale image (numpy array).
        padding: Pixels to add around the detected content box.
        debug_prefix: Prefix for saving debug images.

    Returns:
        The cropped grayscale image (numpy array), or the original if no content found or error occurs.
    """
    print(f"  - Starting content crop (prefix: {debug_prefix})...")
    if gray_image is None or gray_image.size == 0:
        print("  - Error: Input image for cropping is empty.")
        return gray_image # Return input if empty

    original_image_for_fallback = gray_image.copy() # Keep original in case cropping fails

    try:
        # 1. Thresholding (Inverse Binary + Otsu) -> White content, Black background
        h_img_orig, w_img_orig = gray_image.shape
        try:
            _, thresh = cv2.threshold(gray_image, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        except cv2.error as e_otsu: # Handle Otsu failing on uniform images
            if "Could not compute" in str(e_otsu):
                print("  - Warning: Otsu threshold failed in crop. Using simple threshold.")
                _, thresh = cv2.threshold(gray_image, 127, 255, cv2.THRESH_BINARY_INV)
            else: raise e_otsu
        if SAVE_DEBUG_IMAGES: cv2.imwrite(os.path.join(DEBUG_DIR, f"{debug_prefix}_1_crop_thresh.png"), thresh)

        # 2. Find External Contours - these are the outermost boundaries of white areas
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if not contours:
            print("  - Warning: No external contours found for content cropping. Returning original.")
            return original_image_for_fallback

        # 3. Combine all points from contours
        try:
            all_points = np.vstack(contours) # Efficiently stack all contour points
        except ValueError: # Handle case where contours list might be empty despite check
             print("  - Warning: No valid points found in contours for crop. Returning original.")
             return original_image_for_fallback

        if all_points.size == 0:
             print("  - Warning: No points found after stacking contours. Returning original.")
             return original_image_for_fallback

        # 4. Get the final bounding rectangle covering all points
        x, y, w, h = cv2.boundingRect(all_points)
        print(f"  - Content bounding box: x={x}, y={y}, w={w}, h={h}")

        # 5. Apply padding and clamp coordinates
        x1 = max(0, x - padding)
        y1 = max(0, y - padding)
        x2 = min(w_img_orig, x + w + padding) # Use original dimensions for clamping
        y2 = min(h_img_orig, y + h + padding)

        # 6. Crop the image
        if x2 > x1 and y2 > y1:
            # Crop from the original copy we made, NOT the thresholded image
            cropped_image = original_image_for_fallback[y1:y2, x1:x2]
            print(f"  - Applied content crop. New dimensions: {cropped_image.shape}")
            if SAVE_DEBUG_IMAGES: cv2.imwrite(os.path.join(DEBUG_DIR, f"{debug_prefix}_2_crop_result.png"), cropped_image)
            return cropped_image
        else:
            print("  - Warning: Cropping coordinates invalid after padding. Returning original.")
            return original_image_for_fallback

    except cv2.error as e_cv:
        print(f"  - Error during OpenCV operation in content crop: {e_cv}. Returning original.")
        return original_image_for_fallback
    except Exception as e:
        print(f"  - Error during content cropping: {e}. Returning original.")
        return original_image_for_fallback


# --- This function using contours is no longer the primary method, kept for reference/fallback if needed ---
# def get_skew_angle_contours(cropped_gray_image: np.ndarray, debug_prefix="skew") -> float:
#     # ... (previous contour-based skew detection logic) ...
#     pass


def enhance_image(image_path, page_index):
    """Applies crop, skew correction (using deskew lib), CLAHE, and Denoising."""
    debug_prefix = f"page{page_index}_{int(time.time() * 1000)}"
    try:
        img_color = cv2.imread(image_path)
        if img_color is None: raise IOError(f"Could not read image: {image_path}")
        print(f"Enhancing image: {image_path}")
        # 0. Page rectification via perspective transform
        img_color = rectify_page_color(img_color, debug_prefix)

        # 1. Grayscale
        gray_orig = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)
        print("  - Converted to grayscale")
        if SAVE_DEBUG_IMAGES: cv2.imwrite(os.path.join(DEBUG_DIR, f"{debug_prefix}_0_gray.png"), gray_orig)

        # 2. Content-Aware Crop (on original gray) - Helps deskew focus
        gray_cropped = crop_to_content(gray_orig, padding=CROP_PADDING, debug_prefix=f"{debug_prefix}_crop")

        # 3. Skew Detection using `deskew` library (on cropped gray image)
        skew_angle = 0.0 # Default angle
        if USE_DESKEW_LIB:
            try:
                # The library might work better on the grayscale image directly,
                # or sometimes on an inverted thresholded image. Let's try gray first.
                if gray_cropped is not None and gray_cropped.size > 0:
                    print(f"  - Detecting skew using deskew library on cropped image...")
                    # Determine skew angle directly from the cropped grayscale image
                    angle = determine_skew(gray_cropped)

                    if angle is not None:
                        # Limit angle to prevent extreme corrections
                        if abs(angle) <= MAX_SKEW_ANGLE:
                            # Check if angle is significant enough (optional, deskew might handle this)
                            # if abs(angle) >= MIN_SKEW_THRESHOLD:
                            skew_angle = angle
                            print(f"  - Deskew lib detected angle: {skew_angle:.2f} degrees")
                            # else:
                            #      print(f"  - Deskew lib angle {angle:.2f} below threshold {MIN_SKEW_THRESHOLD}. Treating as 0.")
                        else:
                             print(f"  - Deskew lib angle {angle:.2f} exceeds limit {MAX_SKEW_ANGLE}. Assuming 0.")
                    else:
                         print("  - Deskew lib could not determine angle.")
                else:
                    print("  - Skipping skew detection because cropped image is empty.")

            except Exception as e_skew:
                print(f"  - Warning: Skew detection using deskew lib failed: {e_skew}.")
                skew_angle = 0.0 # Assume no skew if detection fails
        else:
             print("  - Skipping skew detection because deskew library is not installed.")


        # 4. Rotation (on CROPPED gray image)
        deskewed_gray = gray_cropped.copy()  # Start with the cropped gray image
        if abs(skew_angle) > 0.001: # Apply rotation if angle is practically non-zero
            if USE_SKIMAGE_ROTATE:
                print("  - Rotating cropped grayscale image using scikit-image...")
                # skimage.transform.rotate expects angle in degrees, counter-clockwise is positive
                # mode='constant' with cval=255 fills background with white
                # order=3 uses cubic interpolation (good quality)
                # preserve_range=True keeps the uint8 range
                rotated_float = rotate(deskewed_gray, skew_angle, resize=False, mode='constant', cval=255, order=3, preserve_range=True)
                # rotated_float is in 0-255 range; convert floats to uint8 directly
                deskewed_gray = rotated_float.astype(np.uint8)
            else: # Fallback to OpenCV rotate
                 print("  - Rotating cropped grayscale image using OpenCV...")
                 # Pass single value for grayscale background color
                 deskewed_gray = rotate_image(deskewed_gray, skew_angle, background_color=(255,))

            print(f"  - Applied rotation of {skew_angle:.2f} degrees.")
            if SAVE_DEBUG_IMAGES: cv2.imwrite(os.path.join(DEBUG_DIR, f"{debug_prefix}_5_rotated.png"), deskewed_gray)
        else:
            print("  - Skipping rotation (angle is 0 or negligible).")
            # deskewed_gray remains as cropped gray

        # 5. Contrast Adjustment (CLAHE) - Apply to the potentially rotated full image
        # clipLimit controls contrast level, tileGridSize controls locality
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        contrast_img = clahe.apply(deskewed_gray)
        print("  - Applied CLAHE contrast enhancement")
        if SAVE_DEBUG_IMAGES: cv2.imwrite(os.path.join(DEBUG_DIR, f"{debug_prefix}_6_clahe.png"), contrast_img)

        # 6. Noise Reduction - fastNlMeansDenoising is good for Gaussian noise
        # Parameters might need tuning: h controls filter strength.
        denoised_img = cv2.fastNlMeansDenoising(contrast_img, None, h=10, templateWindowSize=7, searchWindowSize=21)
        print("  - Applied denoising")
        if SAVE_DEBUG_IMAGES: cv2.imwrite(os.path.join(DEBUG_DIR, f"{debug_prefix}_7_denoised.png"), denoised_img)

        # 7. Save Final Enhanced Image (Overwrite original processed file)
        success = cv2.imwrite(image_path, denoised_img)
        if not success: raise IOError(f"Failed to write enhanced image: {image_path}")

        print(f"Successfully enhanced and saved {image_path}")
        return True

    except Exception as e:
        print(f"Error during image enhancement pipeline for {image_path}: {e}")
        return False


# --- OpenCV Rotation Function (Fallback if scikit-image not available) ---
def rotate_image(image: np.ndarray, angle: float, background_color=(255,)) -> np.ndarray:
    """Rotates a grayscale image by the given angle (degrees) using OpenCV."""
    if abs(angle) < 0.001: return image
    print(f"  - Applying OpenCV rotation of {angle:.2f} degrees")
    (h, w) = image.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    rotated = cv2.warpAffine(image, M, (w, h),
                             flags=cv2.INTER_CUBIC,
                             borderMode=cv2.BORDER_CONSTANT,
                             borderValue=background_color) # Single value for grayscale
    return rotated


# --- process_document function (Handles PDF/Image input and calls enhance_image) ---
def process_document(file_path, doc_id):
    """
    Converts PDF pages to images or processes single images.
    Applies image enhancement pipeline including crop and deskew.
    Saves processed images to processed/<doc_id>/page_<n>.png
    Returns list of relative processed image filenames, or None on failure.
    """
    filename = secure_filename(os.path.basename(file_path))
    doc_processed_dir = os.path.join(PROCESSED_DIR, doc_id)
    ensure_dir(doc_processed_dir) # Ensure processed dir for this doc exists
    processed_files = []
    file_ext = os.path.splitext(filename)[1].lower()

    if file_ext == ".pdf":
        try:
            doc = fitz.open(file_path)
            print(f"Processing PDF {filename}, {len(doc)} pages...")
            for i, page in enumerate(doc):
                page_num = i
                print(f"  - Processing page {page_num + 1}/{len(doc)}")
                # Render page to PNG
                pix = page.get_pixmap(dpi=PDF_DPI)
                output_filename = f"page_{page_num}.png"
                output_path = os.path.join(doc_processed_dir, output_filename)
                try:
                    pix.save(output_path) # Save the raw render first
                except Exception as save_err:
                     print(f"    - Error saving initial PNG for page {page_num + 1}: {save_err}")
                     continue # Skip this page if saving failed

                # Enhance the saved PNG
                if not enhance_image(output_path, page_num):
                    print(f"    - Warning: Enhancement failed for page {page_num + 1}")
                    # Keep original PNG render if enhance fails

                processed_files.append(output_filename) # Add filename even if enhancement failed
            doc.close()
            print(f"Finished processing PDF {filename}.")
        except Exception as e:
            print(f"Error processing PDF {filename}: {e}")
            # Consider cleanup?
            return None
    elif file_ext in [".png", ".jpg", ".jpeg", ".tiff", ".bmp"]:
        try:
            print(f"Processing image {filename}...")
            output_filename = f"page_0.png" # Treat as page 0
            output_path = os.path.join(doc_processed_dir, output_filename)

            # Standardize to PNG using OpenCV before enhancement
            img_temp = cv2.imread(file_path)
            if img_temp is None: raise IOError(f"Failed to read input image {filename}")
            save_success = cv2.imwrite(output_path, img_temp) # Overwrite or create output path
            del img_temp # Release memory
            if not save_success: raise IOError(f"Failed to save temporary PNG")

            # Enhance the saved PNG
            if not enhance_image(output_path, 0): # Pass 0 as page_index
                 print(f"    - Warning: Enhancement failed for image {filename}")
                 # Keep standardized PNG if enhance fails

            processed_files.append(output_filename)
            print(f"Finished processing image {filename}.")
        except Exception as e:
            print(f"Error processing image {filename}: {e}")
            return None
    else:
        print(f"Unsupported file type: {filename}")
        return None

    # Return the list of processed filenames (relative to the doc_id folder)
    return processed_files